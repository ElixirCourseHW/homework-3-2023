# Задача 3 | Времето

## Предговор

Домашните в курса "Функционално прогирамиране с Elixir" ще се предават в Github.
В днешно време винаги, когато се работи с код, се използва [version control](https://en.wikipedia.org/wiki/Version_control) системa, доминиращата от които е [git](https://git-scm.com/). Ако не сте запознати с git, може да прочетете [нашето упътване](https://blog.elixir-lang.bg/materials/posts/how_to_git).

В Github хранилището автоматично ще бъде създаден `Feedback` Pull Request, в който ние можем да ви даваме насоки или Вие да питате въпроси. Ако в рамките на 1 ден не получите обратна връзка, може да се свържете с екипа на курса в Discord, тъй като има вероятност да пропуснем някой въпрос.

Моля следете Discord сървъра на курса. Там ще може да получите допълнителни разяснения и/или корекции на неясноти
по условието на задачата. Екипът на курса не носи отговорност ако пропуснете някое важно съобщение там.

## Оценяване

Разгледайте секциите `Минус точки` и `Бонус точки` в края. Голяма част от оценката на задачата ще бъде направена
на база добър стил, правилно използване на абстракциите за конкурентно програмиране, добра организация на кода,
правилно използване на Supervisor и т.н.

## Задача (20 точки)

> Преди да преминете към имплементация прочетете цялото условие, структурата на проекта и теста.

На Вашия сайт искате да показвате информация за текущото метеорологично време в различни градове.
За целта ще използвате безплатната версия на API-то на [OpenWeatherMap](https://openweathermap.org/api). В документацията в `weather_api.ex` 
файла ще намерите адреса, на който трябва да изпратите заявката.

Но безплатната версия има ограничения:

- Може да изпълните само 1 милион заявки на месец;
- Може да изпълните само 60 заявки на минута.

Вашият сайт е голям и очаквате хиляди посетители всяка минута - не може за всеки потребител да правите нова заявка към OpenWeatherMap. Поради това трябва да
бъде използвана някаква форма на кеширене, за да не превишите лимитите на API-то.

Също така данните трябва да могат да бъдат обновявани (`refresh`) преди да станат "остарели" (`ttl`). Затова вместо само да съхранява данните, вашата програма също така ще ги обновява през определен период от време. По този начин винаги ще имате данни, които можете бързо да покажете на потребителите. В противен случай всеки път, когато данните остареят, потребителите ще трябва да чакат докато вие се сдобиете с новите данни.

> **Работа без регистрация в OpenWeatherMap**
> Споделен API ключ, създаден от тестов акаунт: `186ad7469ef56057ab9ef8522b8efda3`. Можете да го използвате ако изпитвате затруднения с регистрацията (но тя изисква само email). Ако повече хора използват този ключ, то може да получите грешки свързани с Rate Limits.

Публичният интерфейс на Вашата програма изглежда по показания начин.

```elixir
defmodule Weather do
  def start_link(opts)
  def get_weather(city)
  def subscribe_city(city, ttl, refresh_interval)
  def unsubscribe_city(city)
end
```

За по-подробно описание разгледайте файловете.

### Архитектура

Свободни сте изберете сами структурата на процесите във Вашата имплементация, стига
да спазват изискванията изложени в задачата.

- `Weather` - Публичният интерфейс. Чрез него стартирате нов Supervisor, който се грижи за всички останали процеси и под-супервайзъри.
- `Weather.API` - Имплементира връзката с OpenWeatherMap. Изпълнява заявки по мрежата и връща данни в JSON формат. Имплементира `Weather.API.Behaviour`
- `Weather.API.Stub` - Симулира изпълнението на заявки към OpenWeatherMap. Връща предефинирани стойности без да прави заявки. Имплементира `Weather.API.Behaviour`. Използва се за локална разработка и тестване.
- Градовете от всяка държава се обработват от отделен GenServer процес. Такъв процес се добавя, когато град в тази държава се регистрира. Тези процеси са деца на DynamicSupervisor. Използвайте `Registry`, за да регистрирате и търсите тези процеси.

### Публичен интерфейс

Публичните функции на `Weather` са:

#### start_link/1

Стартира Supervisor, който се грижи за всички нужни процеси.

Получава Keyword списък с настройки:
- `:api_module` - По подразбиране използва `Weather.API`. Това е модулът, който ще бъде
  използван за да прави API заявките. В тестовете ще бъде подаден специален модул, който
  връща резултати без да прави заявки по мрежата.

За простота, не получава `:name` аргумент. Няма нужда да поддържате различни имена, така
че да може да се стартират няколко конкурентни процеса, който обработват заявки за времето.
Останалите функции в модула **не** приемат pid или атом, който идентифицира процес.

#### subscribe_city/3

Започва да следи времето в даден град.
Фукцията приема три аргумента:

- `city` - идентификатор на град, състоящ се от името на града и държавата, в която се намира - "Sofia/Bulgaria", "London/UnitedKingdom",
  "Berlin/Germany" и т.н.;
- `ttl` - брой **милисекунди** (число), след изтичането на които данните за
  времето в града трябва да бъдат изтрити от паметта;
- `refresh_interval` - брой **милисекунди** (число), след изтичането на които
  трябва автоматично да се направи нова заявка към API-то, за да се обновят
  данните за времето в града. `refresh_interval` е винаги по-малко от `ttl`;
  Регистрацията на град стартира процедурата по изпълняване на API заявка,
  съхраняване данните и насрочване на изпълнението на нова заявка на всеки
  `refresh_interval` период от време. 

В реална среда бихте използвали стойности като `ttl: :timer.hours(2)` и `refresh_interval: :timer.minutes(15)`.
Това означава, че когато данните се кешират, те ще се пазят най-много 2 часа. През 15 минути данните ще се обновяват. При успешно
обновяване, TTL таймерът също се рестартира и започва обратното отброяване от 2 часа.

Всички градове в една държава се обработват от един процес. Един процес
обработва градовете само в една държава. Тази функция се грижи регистрирането на
града да се случи в правилния процес. Ако процес за тази държава не съществува,
то той бива стартиран.

#### unsubscribe_city/1

Спира проследяването на времето за даден град. Изтрива наличните данни в паметта
и спира всички бъдещи обновявания.

#### get_weather/1

Използвате `get_weather/1` за да получите най-новата информация за времето,
която не е по-стара от `ttl`. Може извиквате `get_weather(city)` само след като
този град е регистриран.

Поведението на `get_weather/1` следното:

- Ако има кеширани данни за времето в града, които не са по-стари от `ttl`, те
  се връщат като резултат;
- Ако няма кеширани данни за времето в града или те са по-стари от `ttl`, извикването
  чака 5 секунди. Ако през това време не се получат нови данни, връща `{:error, :timeout}`.
  Това може да се случи ако веднага след `subscribe_city` извикате `get_weather` докато
  заявката още не се е изпълнила.

Всички градове в една държава се обработват от един процес. Един процес
обработва градовете само в една държава. Тази функция се грижи търсенето на
данните за града да се случи в правилния процес.


### Поток на работа

Когато се регистрира нов град чрез `Weather.subscribe_city/3` се изпълняват следните стъпки:

1. Разделя се името на града и държавата ("Sofia/Bulgaria" -> "Sofia" и "Bulgaria");
2. Проверява се дали има стартиран процес, който се грижи за градовете в дадена държава;
   2.1. Ако няма такъв процес - стартира се и преминава към 3;
   2.2. Ако има такъв процес - преминава към 3.
3. Добавя града в правилния процес.
4. Изпълнява API заявка и записва данните в паметта.

```elixir
# Примерно използване
{:ok, _pid} = Weather.start_link([])

:ok = Weather.subscribe_city("Sofia/Bulgaria", :timer.hours(2), :timer.minutes(15))
:ok = Weather.subscribe_city("Berlin/Germany", :timer.hours(2), :timer.minutes(15))

for _ <- 1..30 do
  # След като данните са кеширани веднъж, всички 60 извиквания тук не водят до
  # нови API завки по мрежата
  {:ok, _weather} = Weather.get_weather("Sofia/Bulgaria")
  {:ok, _weather} = Weather.get_weather("Berlin/Germany")
end
```

### Тестове

> **Работа без достъп до интернет** Вашите тестове **не** трябва да зависят от
> външни ресурси и трябва да бъдат детерминистични. Затова в тестовете не може
> да правите интернет заявки. За целта трябва да може да конфигурирате модула,
> които ще изпълнява тези заявки, по време на компилация.

Напишете няколко **смислени** теста към задачата. Един такъв тест например би
бил тест, който прави следното:

## Разяснения

По-долу са изложени кратки описания на някои от термините.

### Какво време да използвам?

За простота, не следете дали данните са стари или не според времето в API отговора, а според
времето, когато Вие сте изпълнили заявката и сте запазили данните. Ако в 12:00 направите заявки
и получите данни, които са за 09:00, това **не** означава, че данните вече са остарели. 
Правете всички refresh/ttl изчисления спрямо времето, получено чрез `DateTime.utc_now()` по време
на получаване на API отговора.

### Какво е API?

API (Application Programming Interface) е интерфейс, чрез който други програми
могат да използват функционалността на дадена програма. Когато става дума за уеб
технологии, в голяма част от случаите комуникацията се извършва чрез HTTP
заявки, а машината, на която върви въпросната програма наричаме "сървър". Вие
изпращата HTTP заявка на някакъв адрес и получавате отговор, който обработвате в
програмата си (синхронно съобщение).

### Какво е кеширане?

Кеширане, в контекста на тази задача, означава следното:

- Постъпва заявка за времето в град X;
- Проверява се дали тези данни са съхранени в паметта;
- Ако са съхранени, се връщат директно;
- Ако не са съхранени - прави заявка към API-то, данните се съхраняват в паметта
  и се връщат като резултат;

Кешираните данни имат `TTL` (`Time-to-live`). Това означава, че след определен
период от време (`ttl` милисекунди) данните се считат за "остарели" и биват
изтрити от паметта.

Нашата програма може се грижи да обновява данните преди да бъдат остарели.

### Какво е Rate Limiting?

Всички услуги, които ще използвате чрез API за професионални цели, ще имат
ограничения за броя на заявките, които можете да изпълните. Пример: Можете да
изпълните не повече от 60 заявки/минута. Rate Limiting се използва за:

- Защита от злоупотреба;
- Защита от пренатоварване;
- За монетизация - ако заплатите, то ще имате достъп до повече заявки (и до
  повече типове заявки);
- Други причини.

За целите на задачата вие **не** трябва да имплементирате никакъв rate limiting.

### Какви зависимости да използваме?

- За кодиране/декодиране на JSON има един основен пакет - [Jason](https://hexdocs.pm/jason)
- За работа с HTTP заявки има голям набор от пакети, всеки със своите предимства и недостатъци:
  - Може би най-лесен за работа е [Req](https://hexdocs.pm/req)
  - Други използвани пакети са [HTTPoison](https://hexdocs.pm/httpoison), [Tesla](https://hexdocs.pm/tesla), [Mint](https://hexdocs.pm/mint), [Finch](https://hexdocs.pm/finch)

Пример за използване на `Req`:

```elixir
# В iex можем директно да инсталираме пакети
Mix.install [:req]
url = "https://raw.githubusercontent.com/ElixirCourse/code2023/9ffe7a67e7941f1ebc0799365107527c7e7891e8/README.md"
response = Req.get!(url, _headers = [])
response.body
# => "# Код от Функционално Програмиране с Elixir 2023\n\nТук ще бъдат качвани различни Mix проекти, разглеждани в курса."
```

## Минус точки (? брой)

Вече сте запознати с Elixir, а след второто домашно и примерите на лекции имате по-добра представа за функционалния стил на писане на код.
Затова от това домашно нататък за лош стил ще бъдат отнемани точки. Ако успеете да започнете домашното по-рано и да получите обратна връзка и имате време да направите промени, то не трябва да очаквате да получите минус точки.

## Бонус точки (? брой)

Ако искате да получите някакви точки, то трябва да бъдете креативни и да
добавите нещо смислено към задачата. Пример за такива допълнения:

- Записване на данните във файл и зареждане на данните от файл при стартиране.
- Проследяване на потреблението и записване във файл и четене от файл само на
  най-използваните N града.
- Автоматична `unsubscribe_city` функционалност, която дерегистрира град, ако
  неговите данни не са достъпвани за определен (конфигурируем) период от време
  (например `2 * refresh_interval`).
- Ако обновяването се провали поради грешка, то се правят няколко повторни опита
  като се използва [Exponential
  Backoff](https://en.wikipedia.org/wiki/Exponential_backoff)

Тъй като изборът дали и какво да имплементирате към задачата е Ваш, то също така
трябва да напишете тестове за тях, които коректно тестват поведението. Без тестове
няма да получите бонус точките.

Броят точки зависи от сложността на задачата. Ако искате да имплементирате нещо,
по-добре първо го обсъдете с екипа.
